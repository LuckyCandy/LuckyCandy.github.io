## 数据库的控制功能

### 1.事务管理

@info 数据库运行的基本工作单位是<mark>事务</mark>，事务相当于操作系统中的进程，是用户定义的一个数据库操作序列，这些序列要么全做要么全不做，是一个不可分割的工作单位。

数据库事务有 4 大特性(ACID)：

* **原子性(Atomicity)：**操作序列要么全做要么全不做，不可分割；
* **隔离性(Isolation)：**多个事务之间相互隔离，不会相互干扰；
* **持久性(Consistency)：**事务一旦被提交，它对数据库的改变就是永久的，即使发生故障也不应对其有影响；
* **一致性(Durability)：**事务可以使数据从一个一致性状态变换到另一个一致性状态，变换前后，保证数据的完整性。

#### 1.1 隔离级别

为了确保数据的完整性，设计了隔离级别，级别从低到高分别是：<mark>读未提交、读已提交、可重复读、串行化</mark>。

在解释隔离级别之前，先来了解下在没有设置隔离时，可能会出现的问题。

1. **脏读**

所谓脏读，即一个事务读到了另一个事务<mark>更改却未提交</mark>的数据。

<img src="/assets/imgs/architect/database/脏读.png">

2. **不可重复读**

不可重复读，即事务A在两次读取时，第一次读取后数据被其他事务修改，导致两次读取的数据值不一致。

<img src="/assets/imgs/architect/database/不可重复读.png">

2. **幻读**

幻读，和不可重复读相似，单幻读强调的时集合的增减，而不是单条数据的更新。

<img src="/assets/imgs/architect/database/幻读.png">

针对上述问题下面，开始介绍4中隔离级别。

1. **读未提交：**最低的隔离级别，所有事务都能看到其他事务未提交的事务执行结果。只能防止某些更新丢失问题。虽解决上述问题，但具有最高的运行效率。

2. **读已提交：**规定一个事务的更新结果只有在该事务提交之后，另一个事务才能读取到更新结果。可防止脏读，但不能解决不可重复读和幻读问题，执行效率比读未提交要差。

3. **可重复读：**MySQl的默认隔离级别。规定一个事务多次读取同一数据，在这个事务还没结束时，其他事务不能访问该数据（包括读写）。可以解决脏读、不可重复读问题，但不能解决幻读。执行效率更差。

4. **串行化：**最高的隔离级别，他要求事务序列化执行，禁止并行事务。可以解决所有问题，但执行效率最差，还会导致大量的超时现象和锁竞争。

### 2.并发控制

处理并发控制的主要方法时采用**封锁技术**。

* **排他锁（简称X锁、写锁）：**一旦某个事务对数据申请了X锁，在释放之前，该事务<mark>独享数据的读取和修改</mark>，其他事务不能进行任何操作。

* **共享锁（简称S锁、读锁）：**<mark>多个事务可同时对某一相同数据申请S锁</mark>，此时不允许任何事务对数据修改，<mark>只可读取</mark>；在S锁未完全释放前，<mark>任何事务不能对此块数据申请X锁</mark>。

### 3.备份

数据库的备份按照不同的方式可分为多种。按照备份内容可分为<mark>物理备份</mark>和<mark>逻辑备份</mark>。

* **逻辑备份：**指利用DBMS自带的工具软件备份和恢复数据库内容；
* **物理备份：**指在操作系统层面上随数据库的数据文件进行备份，根据备份时是否需要关闭数据库，还可细分为：<mark>冷备份<mark> 和 <mark>热备份</mark>

为了提高物理备份的效率，通常将<mark>完全、增量、差异</mark>三种备份方式结合使用。

|名词|解释|
|-|-|
|完全备份|将数据库的内容<mark>全部备份</mark>，需时较长|
|增量备份|只备份<mark>上次完全、增量或差异备份以来修改</mark>的数据|
|差异备份|备份上次完全备份之后<mark>变化</mark>的数据|
### 4.故障恢复

#### 4.1 事务故障恢复

@info 事务故障恢复是指事务未运行至终点被提前撤销，这时恢复子系统应对此事务做撤销处理。事务故障恢复是由系统自动完成的，无需用户干预。

事务故障恢复的步骤如下：
* 反向扫描文件日志，查找该事务的更新操作；
* 对该事务的更新操作执行逆操作；
* 继续反向扫描日志文件，查找该事务的其他更新操作，做逆向处理；
* 直到此事务的开始标记，事务恢复完成。

#### 4.2 系统故障恢复

系统发生故障，造成数据库数据不一致的情况有两种：
1. 未完成事务对数据库的更新一些如数据库；
2. 已完成的事务对数据的修改还在缓冲区，未来得及写入数据库。
此故障会在系统重新启动时自动完成修复，也不需要用户干预，其步骤如下：
    * 正向扫描日志文件，找出发生故障前提交的事务，将事务标识记入重做(Redo)队列。同时找出故障发生时未完成的事务，将事务标识计入撤销(Undo)队列；
    * 对撤销队列中的各个事务进行撤销处理：反向扫描日志文件，对每个Undo事务的更新操作执行逆操作；
    * 对重做队列中的各个事务进行重做处理：正向扫描日志文件，对每个Redo标识的事务重新执行日志文件登记的操作。

#### 4.3 介质故障与病毒破坏的恢复

在发生介质故障与病毒破坏时，磁盘上的物理数据被破坏，此时恢复的操作分为三步：
* 装入最新数据的后备副本，是数据恢复到最近一次转储时的状态；
* 从故障点开始反向读取日志，找出已提交的事务加入Redo队列；
* 从起始点正向阅读日志文件，根据重做队列中的记录，重做所有事务。

#### 4.4 具有检查点的恢复技术

检查点建立时会记录此刻所有正在执行的事务清单，以及这些事务的日志地址。由此，其恢复步骤如下：
* 找到最后一个检查点记录
* 在检查点记录得到建立时所有正在执行的事务清单（A）
* 建立重做队列（R）和撤销队列（U），把A放入U，重做队列置为空。
