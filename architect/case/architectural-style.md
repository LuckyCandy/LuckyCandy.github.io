## 架构风格

@info 软件体系架构风格是描述<mark>某一特定应用领域</mark>中系统组织方式的<mark>惯用模式</mark>，反映了领域中众多系统所共有的<mark>结构</mark>和<mark>语义特性</mark>，并指导如何将各个模块和子系统有效地组织成一个完整的系统。

<img src="/assets/imgs/architect/case/经典架构风格.png">

--- 

### 1. 数据流风格

所有的数据按照流的形式在执行过程中前进，经过序列间的数据处理组件进行处理，然后将处理结果向后传送，最后进行输出。

#### 1.1 批处理

批处理风格的每一步都是独立的，并且每一步都是顺序执行的。只有当前一步处理完，后一步才能开始处理。<mark>数据必须是完整的</mark>，以整体的方式传递。

#### 1.2 管道过滤器

每个构件都有一组输入和输出，构件读输入的数据流，经过内部处理，然后产生输出数据流，传递给下一个构件，每个环节相互独立又环环相扣。

#### 1.3 批处理 VS 管道过滤器
<p/>

批处理 | 管道过滤器
:-:|:-:
整体数据传送|增量（部分）数据
构件的粒度大|构件的粒度小
延迟高、实时性差|实时性好
无并发|可并发

---

### 2.调用返回风格

#### 2.1 主程序/子程序
主程序/子程序一般采用单线程控制，把问题划分为若干处理步骤，主程序的正确性取决于它调用子程序的正确性。

#### 2.2 面向对象
面向对象风格将数据的表示和相应的操作封装起来，对象的行为体现在其接受和请求的动作中。

对象具有封装性，一个对象的改变不会影响其他对象。

**优点**：
1. 将数据和行为封装，在系统启动时加载，安全性高；
2. 由于直接加载数据对象，执行的性能较好；

**缺点**：
1. 加入新的改变需要增加新的类来进行扩展，需要通过系统重启、动态反射或动态加载扩展，扩展性较差

#### 2.3 层级结构
层次结构的每层只为上一层提供服务，并使用下一层提供的功能。修改某一层也只影响与自己邻接的层（通常只影响上层，因为上层会使用它提供的服务）。

---

### 3.独立构件风格
独立架构风格的特点：事件的触发者并不知道哪些构件会被这些事件影响，构建间无耦合。
#### 3.1 进程通信
进程间消息传递的方式可以是点对点、异步或同步方式，以及远程过程（方法）调用。
#### 3.2 事件驱动
构件不直接调用一个过程，而是触发或广播一个或多个事件。构件中的过程在一个或多个事件中注册，当某个事件被触发时，系统自动调用这个事件中注册的所有过程。

**优点**：为软件复用提供了支持，为构件的维护和演化带来了方便<br/>
**缺点**：放弃了对系统计算的控制

---

### 4.虚拟机风格
当底层不支持上层时，在两者之间加入一层虚拟机做模拟仿真，以此来消除软件和硬件之间的差异。比如在Windows上安装Android模拟器等。

#### 4.1 解释器风格
解释器通常包含一个完成解释工作的解释引擎，一个包含将被解释的代码的存储区、一个记录解释器引擎当前工作状态的数据结构、以及一个记录源代码被解释执行进度的数据结构。

**缺点**：执行效率低，如JVM

#### 4.2 基于规则的系统
基于规则的系统包括规则集、规则解释器、规则/数据选择器和工作内存。一般应用在人工职能领域和DSS中。

**优点**：
1. 根据定义好的规则，在系统启动时加载，支持运行过程中动态更新，灵活性较好；
2. 如果有新的规则加入，只需要定义规则便可进行扩展，扩展性比较好。

**缺点**：
1. 需要实时对规则进行解析，性能较差。

---

### 5.仓库风格

#### 5.1 数据库系统
构件分为中央共享数据源、独立处理单元。构件控制中央共享数据。如IDE集成开发环境。

#### 5.2 黑板
黑板包括<mark>知识源</mark>、<mark>黑板</mark>和<mark>控制</mark>三个部分。

知识源包括若干独立计算的不同单元，提供解决问题的知识。它响应黑板的变化，也只修改黑板；

黑板是一个全局数据库，它包含问题域解空间的全部状态，是知识源相互作用的唯一媒介。

#### 5.3 超文本系统
静态网页