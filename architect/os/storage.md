## 存储管理

### 1.地址重定位

**逻辑地址**：也称为相对地址，一般以0作为基址，是内部和编程使用的、并不唯一；<br/>
**物理地址**：也称为绝对地址，是加载到内存地址寄存器的地址，内存单元的真正地址。

<mark>地址重定位则是i将程序中的虚拟地址（逻辑地址）变换为内存的真实地址（物理地址）的过程。</mark>

地址重定位分为：**静态重定位** 和 **动态重定位**

* 静态重定位：<span style="color:blue">绝对地址 = 相对地址 + 程序存放的内存起始地址</span>
* 动态重定位：<span style="color:blue">绝对地址 = 重定位寄存器的值（BR）+ 逻辑地址寄存器的值（VR）</span>

静态重定位和动态重定位的优缺点：

* 静态重定位需要在程序运行前就确定程序的位置（地址的映射关系）且不能移动，程序本身也需要占用连续的内存空间；

* 动态重定位可以再程序需要执行是根据BR和VR的记录去调度，占用的内存空间可动态变化，相对比较灵活，但增加了寄存器的开销

### 2.分区存储管理
@info 将主存的用户区划分为若干区域，每个区域再分配给一个用户作业去使用，并且限定只能在自己的区域内运行。

分区存储有三种划分形式：
1. **固定分区**：顾名思义，按照一定大小划分连续区域，并将分区信息记录成一张分区表，记录信息如下：

<img src="/assets/imgs/architect/os/storage/固定分区.jpg">

[缺点：]{color:red;font-weight:bold}固定大小不完美匹配用户作业所需，会造成大量的空间浪费。

2. **可变分区**：对固定分区的改良，可以根据用户作业的大小，使用不同的算法去分配合适的区域空间

<img src="/assets/imgs/architect/os/storage/可变分区.jpg">

[缺点：]{color:red;font-weight:bold}增加了分配时间，并没有完全解决空间浪费问题。

3. **重定位分区**：过移动内存中作业的位置，然后把原来多个分散的空闲小分区拼接成一个大分区。此时若不对程序和数据的地址加以修改（变换），则程序必将无法执行。为此，在每次“紧凑”后，都必须对移动了的程序或数据进行重定位。

<img src="/assets/imgs/architect/os/storage/重定位分区.jpg">

[缺点：]{color:red;font-weight:bold}重定位会增加系统开销，必须选择合适的时机进行，通常有一下两种：<br/>
   1. 分区回收时执行；
   2. 找不到足够大空间时执行：

### 3.分页存储管理
@info 把主存存储空间划分为大小一定的块（称为物理块、或页框），把要执行的作业也按照同样的尺寸划分，如此作业便可以零散的放于主存的不连续的页框中，但需要增加页表(页号和页框的映射关系)去寻址。

<img src="/assets/imgs/architect/os/storage/分页存储管理.jpg">

如上图所示：<br/>用户作业按照一定的大小切分，切分后的每一个区域称为：**页面** 或 **页**；<br/>主存也按照这个大小进行划分，划分后的每一个区域称为：**页框**<br/>如此，每个页便刚好放入页框内，维持页号和页框之间关系的便是**页表**。

结合地址重定位和分页存储，做个题目来巩固加深认识：<br/>
[例题：]{color:red;font-weight:bold}每个页和物理块的大小均为1024B，页表如下，求逻辑地址2100的真实地址？

<img src="/assets/imgs/architect/os/storage/页表.jpg">

[解：]{color:red;font-weight:bold}
1. 求逻辑地址所在页号：2100 / 1024 > 2，在第三页，由于页号是从 **0** 开始，因此页号为：**2**
2. 求逻辑地址在第二页中的偏移：2100 % 1024 = 52
3. 查询页表，页号为2的物理块号为8， 每块大小再加上偏移地址即为答案：8 * 1024 + 52 = 8244

### 4.分段存储管理
@info 分段式存储管理的作业空间是以段为单位的，每个段将占据一个连续的存储区域，但各段之间不必连续。这样，一个作业的各个分段在主存的情况用一个段表来记录，它指出了主存中各个分段的起始地址和长度。

<img src="/assets/imgs/architect/os/storage/分段存储管理.jpg">

<mark>相对于分页存储来说，分段可以根据程序的实际情况，将程序内联系比较紧密的部分划分到一个段内，保护程序内部的逻辑完整性。</mark>

### 5.段页式存储管理
@info 段页式存储管理兼顾了段式在逻辑上的清晰和页式在管理上方便的特点。

<img src="/assets/imgs/architect/os/storage/段页式存储管理.jpg">

此种管理方式下，逻辑地址到物理地址的转换步骤如下：
* 访问段表获取段表始址
* 根据段表始址计算段表分页的页号，从而得到页表始址
* 根据得到的页表地址得到具体的物理

### 6.虚拟存储

@info 不同于其他存储管理方式，虚拟存储允许<mark>将作业的一部分装入主存</mark>，其余部分暂时在磁盘上，在需要时再装入主存。

之所以称之为虚拟存储，是因为将外存(磁盘等)虚拟成内存使用，在用户角度是无感知的。这种方式可以有效的利用主存空间，一定条件下可运行更大的用户作业。

### 7.真题解析
*进程P有8个页面，页号分别为0~7，页面大小为4K。系统为进程P分配了4个存储块，页表如下。表中状态位上的1或者0分别代表页面在内存和不在内存*

|页号|页框|状态位|访问位|修改位|
|-|-|-|-|-|
|0|-|0|0|0|
|1|7|1|1|0|
|2|5|1|0|1|
|3|-|0|0|0|
|4|-|0|0|0|
|5|3|1|1|1|
|6|-|0|0|0|
|7|9|1|1|0|

[问题：]{color:red;font-weight:bold}
1. 求逻辑地址5148H的真实地址（16进制表示）？
2. 访问页面6不在内存，那么应该淘汰()号页面？

[第一问：]{color:red;font-weight:bold}
1. 逻辑地址5148H位16进制，所求也为16进制，我们便统一使用16进制来计算。<br/>页面大小位4K = 2^12 = (2^4)^3 = 16^3 = 1000H
2. 求页号，5148H / 1000H > 5, 页号应为6，由于页号从0开始编址，故页号位5
3. 求页内偏移，5148H % 1000H = 148H
4. 查询页表得知，页框号位3，真实地址 = 3 * 1000H + 148H = 3148H

[第二问：]{color:red;font-weight:bold}
* 由于系统为进程P分配了4个存储块，在页表中可看到，4个存储块皆在内存中。如果需要载入新的数据，则需要覆盖页面；
* 根据页面的访问位得知，2号页暂时没有访问，所以，因淘汰2号页面。

延申以下：如果访问位相同，则应该优先淘汰修改位为0的。