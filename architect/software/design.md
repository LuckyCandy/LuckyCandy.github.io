## 系统设计

### 1.概述
系统设计阶段又称为物理设计阶段，其任务是根据系统规格说明书中规定的功能要求，设计新系统的物理模型，为下一阶段的系统实现奠定基础。<br/>

系统设计阶段分为两个部分：<mark>概要设计</mark>和<mark>详细设计</mark>。

|概要设计|详细设计|
|:---:|:---:|
|又称为<mark>系统总体结构设计</mark>，主要任务是将系统的功能需求分配给软件模块，确定每个功能模块的功能和模块间的调用关系，形成软件的<mark>模块结构图</mark>，也就是<mark>系统结构图</mark>。软件概要设计将软件需求转化为<mark>数据结构</mark>和<mark>软件的系统结构</mark>。|对结构图进行细化，得到<mark>详细的数据结构和算法</mark>。详细设计主要包括：网络设计、代码设计、输入输出设计、处理流程设计、数据存储设计、用户界面设计、安全性和可靠性设计等|

#### 1.1 概要设计
概要设计过程中主要使用<mark>模块结构图</mark>、<mark>层次图</mark>和<mark>HIPO图</mark>。
* **模块结构图：**又称为<mark>系统结构图</mark>，特使软件概要设计阶段的工具，反应系统的功能实现和模块之间的联系和通信，包括各模块之间的层次结构，即反应了系统的总体结构。
* **HIPO图(Hierarchy plus Input-Process-Output)：**它主要包括两个部分层次图和IPO图，层次图用来描述系统结构，IPO图用来描述每个模块的输入、输出和数据加工。<br/>IPO图的处理过程，可以采用流程图、判定树/表来进行描述。

#### 1.2 详细设计
详细设计阶段过程主要使用：<mark>程序流程图</mark>、<mark>伪代码</mark>、<mark>盒图</mark>。

<img src="/assets/imgs/architect/software/design/详细设计过程用图.png">

**处理流程设计：**处理流程设计是系统详细设计的重要组成部分，主要目的是确定各系统模块的内部结构，即内部执行过程，包括局部数据组织和控制流，以及每个具体加工过程和实施细节。

**常见的流程设计图形工具有：**程序流程图、IPO图、盒图、问题分析图、判定树

**常见的流程设计表格工具有：**判定表

**常见的流程设计语言工具有：**过程设计语言

**问题分析图（Problem Analysis Diagram，PAD）：**包含五种控制结构，允许递归使用。

<img src="/assets/imgs/architect/software/design/问题分析图.png">

**判定表：**对于具有多个相互联系的条件和可能产生多种结果的问题，用结构化语言描述显得不够直观；可以使用判定表来描述。

<img src="/assets/imgs/architect/software/design/判定表.png">

**判定树：**也是用来表示逻辑判断问题的一种常用的图形工具，用树来表达不同条件下的不同处理流程，比表格更加直观。判定树的左侧（树根）为加工名，所有的行动都列于最右侧。

<img src="/assets/imgs/architect/software/design/判定树.png">

### 2.结构化设计
结构化设计是一种面向数据流的方法，它以SRS和SA阶段所产生的数据流图和数据字典等文档为基础，是一个自顶向下、逐步求精和模块化的过程。

软件的结构化设计包括<mark>体系结构设计</mark>、<mark>接口设计</mark>、<mark>数据设计</mark>和<mark>过程设计</mark>。

|设计种类|描述|
|-|:-:|
|体系结构设计|定义软件系统各主要部件之间的关系|
|数据设计|将模型转换成数据结构定义。好的数据设计将改善程序结构和模块划分，降低过程复杂性|
|接口设计|软件内部，软件和操作系统间以及软件和人之间如何通信|
|过程设计|系统结构部件转换成软件的过程描述|

结构化设计的特征如下：
* 信息隐蔽与隐藏。通过信息隐蔽可以提高软件的<mark>可修改性</mark>、<mark>可测试性</mark>和<mark>可移植性</mark>。
* 模块化
* 高内聚与低耦合

### 3.面向对象设计

面向对象的分析与设计过程：

<img src="/assets/imgs/architect/software/design/面向对象的分析与设计过程.png">

**面向对象的设计过程可分为：**
1. **设计用例实现方案**。UML的交互图（顺序图、协作图）适用于实现方案的表示。该设计方案包含如下三个步骤：<br/>(1) 提取边界类、实体类和控制类；<br/>(2) 构造交互图，以交互图作为用例的精确实现方案<br/>(3) 根据交互图精化类图。

2. **设计技术支撑方案**。需要一组技术支撑机制为其提供服务。例如：数据持久存储服务、安全控制服务、分布式事务管理服务、并发与同步控制服务和可靠消息服务等。

3. **设计用户界面**。

4. **精化设计模型**。

#### 3.1 设计原则

<img src="/assets/imgs/architect/software/design/设计原则.png">

#### 3.2 设计模式

<img src="/assets/imgs/architect/software/design/设计模式.png">

1. **工厂模式**。定义一个用户创建对象的接口，让子类决定将哪一个类实例化。

2. **抽象工厂模式**。提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

3. **建造者模式**。将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。

4. **原型模式**。用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

5. **单例模式**。保证一个类仅有一个实例，并提供一个访问它的全局访问点。

6. **适配器模式**。将一个类的接口转换成客户希望的另外一个接口。

7. **桥接模式**。将抽象部分与实现部分分离，使它们都可以独立的变化。

8. **组合模式**。将对象组合成树形结构以表示"部分-整体"的层次结构。

9. **装饰器模式**。动态地给一个对象添加一些额外的职责。

10. **外观模式**。为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

11. **享元模式**。运用共享技术有效地支持大量细粒度的对象。

12. **代理模式**。为其他对象提供一种代理以控制对这个对象的访问。

13. **责任链模式**。避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。

14. **解释器模式**。给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。

15. **模版方法**。定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

16. **命令模式**。将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。

17. **迭代器模式**。提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。

18. **中介者模式**。用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

19. **备忘录模式**。在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。

20. **观察者模式**。定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

21. **状态模式**。允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。

22. **策略模式**。定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。

23. **访问者模式**。主要将数据结构与数据操作分离。

