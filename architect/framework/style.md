## 软件架构风格

### 1.概述
软件体系结构（架构）风格是描述<mark>也顶应用领域</mark>中系统组织方式的<mark>惯用模式</mark>。架构风格定义一个系统家族，即一个体系结构定义<mark>一个词汇表</mark>和<mark>一组约束</mark>。
* **词汇表：**包含一些构件和连接件类型；
* **约束：**指出系统是如何将这些构件和连接件组合起来的。

架构风格反应了领域中众多系统所共有的<mark>结构</mark>和<mark>语义特性</mark>，并指导如何将各个子模块和子系统有效的组织成一个完整的系统。

### 2.架构风格

软件架构风格主要由以下几种：

<img src="/assets/imgs/architect/framework/软件架构风格.png">

#### 2.1 数据流风格
所有的数据按照流的形式在执行过程中前进，不存在结构的反复和重构，就像工厂中的汽车流水线一样，数据就像汽车零部件在流水线的各个节点被加工，最终输出所需要的结果。在流动过程中，数据经过序列件的数据处理组件进行处理，然后将处理结果向后传送，最后进行输出。<br/>
**数据流风格主要有：**<mark>批处理、管道过滤器</mark>两种。

1. **批处理风格**
批处理应用的基本流程是：<br/>
1）从数据库、文件等数据媒介读取大量记录；
2）数据处理组件处理数据；
3）处理结果写回数据

<img src="/assets/imgs/architect/framework/批处理架构.png">

**批处理架构的应用场景：**
1. 日志分析
2. 计费应用程序
3. 数据仓库

2. **管道过滤器风格**
管道过滤器风格的特点是：
* 系统任务分成若干连续的处理步骤，这些步骤由通过系统的数据流连接，一个步骤的输出是下一个步骤的输入;
* <mark>每个构件都有一组输入和输出，构件读输入的数据流，经过内部处理，然后产生输出数据流</mark>;
* 过滤器必须是独立的实体，它不能与其它的过滤器共享数据，而且一个过滤器不知道它上游和下游的标识。

<img src="/assets/imgs/architect/framework/管道过滤器风格.png">

比较典型的应用管道过滤器的场景就是Web容器的Filter过滤机制、编译器、媒体播放器等。

<img src="/assets/imgs/architect/framework/管道过滤器风格应用.png">

**管道过滤器风格 VS 批处理风格**

|批处理|管道过滤器|
|:---:|:---:|
整体数据传输|增量
构件粒度大|构件粒度小
延迟高、实时性差|实时性好
无并发|可并发

#### 2.2 调用返回风格
调用返回风格主要由<mark>主程序/子程序</mark>、<mark>面向对象</mark>和<mark>层次</mark>组成。

1. **主程序/子程序风格**

简单来说就是函数/功能的调用：

<img src="/assets/imgs/architect/framework/主子程序风格.png">

2. **面向对象风格**

数据的标识和他们的相应操作都被封装起来，对象的行为体现在其接受和请求的动作中。由于这种封装性，一个对象的改变不会影响其他对象。

<img src="/assets/imgs/architect/framework/面向对象风格.png">


3. **层次风格**

每一层为上一层服务，使用下一层的服务，只能见到与自己邻接的层。在层次结构中，修改某一层，最多影响相邻的上下层（通常只影响上层，即被服务层），上层需知道下层的身份，层次之间不可调换顺序。

<img src="/assets/imgs/architect/framework/架构图样例.png">

#### 2.3 独立构件风格
独立构件风格主要由<mark>进程通信</mark>和<mark>事件驱动</mark>两种；这种风格的主要特点是：<mark>事件的出发这并不知道有哪些构件会被这些事件影响，构件件保持独立</mark>。

1. **进程通信**

进程通信风格中，构件是独立的过程，连接件是消息传递。

进程间消息传递的方式可以是点对点、异步或同步方式，以及远程方法调用。

<img src="/assets/imgs/architect/framework/进程间通信方式.png">

2. **事件驱动风格**

构件不直接调用一个过程，而是触发或广播一个或多个事件。构件中的过程在一个或多个事件中注册，当某个事件被触发时，系统自动调用这个在事件中注册的所有过程。

<img src="/assets/imgs/architect/framework/事件驱动风格.png">

#### 2.4 虚拟机风格
当底层不支持上层时，在两者之间加入一层虚拟机做模拟仿真，消除硬件和软件之间的差异。

虚拟机风格有<mark>解释器</mark>和<mark>基于规则的系统</mark>两种

1. **解释器风格**

解释器通常包括一个完成解释工作的解释引擎、一个包含将被解释的代码的存储区、一个记录解释器当前工作状态的数据结构以及一个记录源代码被解释进度的数据结构。

缺点时执行效率偏低，如JVM

<img src="/assets/imgs/architect/framework/解释器风格.png">

2. **基于规则的系统**

包括规则集、规则解释器、规则/数据选择器和工作内存。一般应用在人工智能呢个领域和DSS中。

<img src="/assets/imgs/architect/framework/基于规则的系统.png">

#### 2.5 仓库风格
仓库风格主要有<mark>数据库系统</mark>、<mark>黑板</mark>和<mark>超文本系统</mark>三种。

1. **数据库系统**

构件分为中央共享数据源、独立处理单元。构件控制中央共享数据。比如：windows系统的注册表、IDE集成开发环境等。

<img src="/assets/imgs/architect/framework/数据库系统风格.png">


2. **黑板**

黑板系统包括<mark>知识源</mark>、<mark>黑板</mark>和<mark>控制</mark>三个部分。知识源包括若干独立计算的不同单元，提供解决问题的知识。知识 源响应黑板的变化，也只修改黑板；<br/>黑板时一个全局数据库，包含问题域解空间的全部状态，是知识源相互作用的唯一媒介；知识源响应式通过黑板状态变化来控制的。

<img src="/assets/imgs/architect/framework/黑板.png">


3. **超文本系统**

即静态网页。

#### 2.6 闭环控制
闭环（过程）控制是将过程输出的指定属性维护在一个特定的参考数值（设定值），将事务处理看成输入、输出、反馈、在输入的一个持续的过程模型。比如：空调的温度自动调节器、巡航系统

闭环控制是根据控制对象输出反馈来进行校正的控制方式。

#### 2.7 C2风格

C2架构风格可以概括为：通过连接件绑定在一起按照一组规则运作的并行构件网络。

C2风格中的系统组织规则如下：
1. 系统中的构件和连接件都有一个顶部和一个底部；
2. 构件的顶部应连接到某个连接件的地步，构件的底部则应连接到某连接件的顶部，<mark>构件与构件之间式不允许之间连接的</mark>。
3. 一个连接件可以和任意数目的其他构件和连接件连接；
4. 当两个连接件直接相连时，必须<mark>由其中一个的底部连到另一个的顶部</mark>。

<img src="/assets/imgs/architect/framework/C2风格.png">

#### 2.8 二层C/S架构
二层C/S架构为单一服务器且以局域网为中心，所以难以扩展至大型企业广域网或Internet，主要缺点有：
* 服务器负荷太重，难以管理大量的客户机，系统的性能容易变坏；
* 数据安全性不好。因为客户端直接可以访问数据库服务器，那么在客户端计算机上的其他程序也可以连接数据库。

<img src="/assets/imgs/architect/framework/CS架构风格.png">

#### 2.8 三层C/S架构
在二层架构基础之上增加了一个应用服务器。可以将整个应用逻辑驻留在应用服务器上，而只有表示层存在于客户机上。这种客户机称为<mark>瘦客户机</mark>。

<img src="/assets/imgs/architect/framework/三层CS架构分层.png">

三层C/S架构的数据处理流程如下：

<img src="/assets/imgs/architect/framework/三层CS架构处理流程.png">

#### 2.9 B/S架构
浏览器/服务器（Browser/Server，B/S）架构时三层C/S架构的一种实现方式，其具体结构为“浏览器/Web服务器/数据库服务”。

<img src="/assets/imgs/architect/framework/BS架构.png">